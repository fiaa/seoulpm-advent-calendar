Title:    펄에서 외부명령어 실행 시키기
Package:  Seoul.pm
Category: perl
Category: Seoul.pm
Author:   John Kang


시작하며
---------

펄에서 외부 명령어를 실행시키는 방법은 여러 가지가 있습니다.
[system 내장 함수][perldoc-system], [`...`][perlop-string]처럼 역따옴표,
[open 내장 함수][perldoc-open]로 파이프(pipe)를 생성하는 방법 등이 있습니다.
이러한 방법의 동작과 차이점을 살펴보고 [Capture::Tiny 모듈][cpan-capture-tiny]을
이용해 외부 명령어를 손쉽게 실행시키는 방법에 대해 알아봅니다.

외부 명령어를 펄을 통해 실행시킬 때는 표준 출력/에러의 방향과 외부 명령어가
반환하는 종료값을 인지해야 할 경우가 많습니다.
간단하게 기본적으로 제공하는 방법을 이용하지 않고 복잡하게 모듈까지 설치해서
외부 명령어를 실행하는지에 대한 의문은 각각의 차이점을 먼저 비교해보고 설명하겠습니다.


system 내장 함수
-----------------

`system` 함수는 펄의 내장 함수로써 외부 명령어를 실행시킬 수 있습니다.
사용방법은 다음과 같습니다.

    #!perl
    #
    # system LIST
    # system PROGRAM LIST
    #
    my $exit_status = system('ls');
    #
    # return : $exit_status, $?
    # stdout : STDOUT
    # stderr : STDERR
    #
 
`system` 함수의 반환값은 외부 명령어가 반환한 종료값입니다.
따라서 `$exit_status`는 `ls` 명령어의 종료값을 담습니다.
대부분의 운영제체에서 외부 명령어의 정상적인 종료 코드는 `0`이기 때문에 `system` 함수에서
실행한 외부 명령이 성공적으로 종료되면 `system`의 반환값은 `0`이 됩니다.

`system` 함수는 `fork`를 이용해 자식 프로세스를 생성하고 자식 프로세스에서 외부 명령어를 실행합니다.

    #!plain
    init --> perl --> ls

이 때 사용자가 임의로 표준 출력과 표준 에러의 파일 핸들을 수정하지 않았다면,
`ls` 명령어의 표준 출력은 *펄의 표준 출력(1)*으로, 에러는 *펄의 표준 에러(2)*를 상속 받습니다.
[fileno 내장 함수][perldoc-fileno]를 이용하면 해당 파일 핸들의 파일 디스크립터 값을 알 수 있습니다.

    #!perl
    print fileno STDOUT ## 1


역따옴표(`)
------------

역따옴표으로 외부 명령어를 실행하는 방법은 쉘에서의 그것과 동일합니다!
펄에는 크게 스칼라 문맥(scalar context)과 목록 문맥(list context)
두 가지가 존재하며 영어의 단수와 복수 개념과 비슷합니다.
역따옴표의 결과는 펄의 두 문맥에 따라 달라집니다.

다음은 스칼라 문맥에서의 역따옴표를 사용한 경우입니다.

    #!perl
    my $output_string = `ls`;
    - return : $?
    - stdout : $out_string
    - stderr : STDERR

외부 명령어의 종료값은 `$?` 변수에 저장되며 역따옴표는 외부 명령어가 표준 출력에 출력한 모든 내용을
반환하기 때문에 앞의 예제의 경우 디렉토리와 파일의 목록이 `$output_string` 변수에 저장됩니다.
표준 오류는 역따옴표를 실행하기 전의 펄의 표준 오류와 동일하기 때문에 오류를 확인하고 싶다면
외부 명령어를 실행할 때 표준 오류의 방향을 변경(재지향, redirect)해야 합니다.

    #!perl
    my $output_string = `ls 2 > &1`;

다음은 목록 문맥에서의 역따옴표를 사용한 경우입니다.

    #!perl
    my @output_string = `ls`;
    - return : $?
    - stdout : @out_string line terminated by $/;
    - stderr : STDERR

아니 똑같아 보이는데 왜 목록 문맥이냐고요?
`=` 연산자 왼쪽의 값이 `$output_string`이 아닌 `@output_string`이기 때문에 펄은 이 구문을 목록 문맥으로 처리합니다.
목록 문맥에서 역따옴표는 외부 명령어의 실행 결과를 `$/` 변수의 값(기본 값은 해당 운영체제의 줄바꿈 문자)을 구분자로
나누어 각각의 줄 단위로 실행 결과를 반환합니다.
따라서 `@output_string`은 한 줄 단위로 구분된 문자열 목록을 가집니다.

`qx()`는 역따옴표의 또 다른 표현으로 둘은 완전히 동일합니다.

    #!perl
    my $output_string = qx(ls);
 
실행할 구문에 쉘이 해석해야 할 메타 문자가 있다면 다음처럼 작은 따옴표를 괄호 대신 사용하세요.

    #!perl
    my $output_string = qx'ps $$';


`open` 함수로 파이프 열기
--------------------------

전통적으로 파이프를 이용하면 외부 명령어와 데이터를 주고받을 수 있습니다.
`open` 내장 함수로 파이프를 열 수 있는데 이때 두 번째 인자에 따라
파이프 생성 및 모드를 지정할 수 있습니다.
두번째 인자의 앞 부분에 `|` 기호를 사용하면 쓰기 모드로 파이프를 생성하며
뒷 부분에 `|` 기호가 오면 읽기 모드로 파이프를 생성합니다.

다음은 현재 디렉터리에서 30일이 지난 로그 파일을 삭제하는 간단한 프로그램입니다.

    #!perl
    #!/usr/bin/env perl

    use strict;
    use warnings;

    open( my $pipe, 'ls |' ) or die "Can't open a pipe : $!\n";
    while (<$pipe>) {
        chomp;                    ## 파일명뒤의 개행(\n) 삭제

        next unless -f;           ## 파일만 추출
        next unless /\.log$/i;    ## *.log 파일만 추출

        unlink if -M > 30;        ## -M 으로 파일변경시간 확인(in day)후 삭제
    }

`open` 함수를 실행하는 중에 오류가 발생할 경우 `$!` 변수를 확인해 어떤 오류가 발생했는지 확인할 수 있습니다.

다음은 `/bin/mail` 명령을 이용해 메일을 보내는 예제입니다.

    #!perl
    #!/usr/bin/env perl

    use strict;
    use warnings;
    use autodie;

    open( my $body, '| /bin/mail -s Subject mail@domail.com' );
    print {$body} 'Hi There, I hope you are doing well :)';

예제는 `$body` 파이프를 통해 입력 결과를 `/bin/mail`에게 전달합니다.
[autodie 프라그마][cpan-autodie]를 통해 `open` 함수의 오류 제어를 자동화하면 편리합니다.


Capture::Tiny
--------------

위의 방법만으로도 충분히 외부 명령어를 실행 시키는데 큰 무리는 없습니다.

허나 어떤 외부명령어는 실행중 표준출력과 표준에러가 동시에 발생하기도 합니다.

위의 방법으로는 표준출력과 에러를 다른 변수에 각각 저장하기에는 프로그래머의 많은 코딩을 요구 합니다.
(사실 어떤 노력이 필요 한지 모릅니다;;)

펄에는 CPAN 이 있습니다!!

JEEN_LEE 님께서 작성해주신 셋째날의 기사를 참고해보면 Capture::Tiny는 [43위에 랭크][cpan-leaderboard] 되어있고, 아래와 같은 이점이 있습니다.

- Perl, XS 코드 또는 외부명령어에서 반환하는 표준출력과 표준에러를 Capture 하는 portable한 방법을 제공.
- tee라는 함수를 사용하여 표준출력, 표준에러를 변수에 담는것은 물론 동시에 원래의 STDOUT, STDERR로 출력.

    #!perl
    use autodie;
    use Capture::Tiny ':all';

    my @cmd = qw( find /proc -type f );
    my ($stdout, $stderr, $exit) = capture {
        system @cmd;
    };

 system() 함수의 결과를 통해 capture함수가 표준출력, 표준에러 그리고 외부명령어의 종료값을 반환합니다.

 그리고 우리는 표준출력과 에러를 구분해서 사용할 수 있습니다.

    #!perl
    my $out_fh = IO::File->new("out.log", "w+");
    my $err_fh = IO::File->new("err.log", "w+");

    my @cmd = qw( find /proc -type f );
    capture { system @cmd } stdout => $out_fh, stderr => $err_fh;

위와 같이 capture 함수에 옵션을 제공함으로써 stdout과 stderr를 파일에 쓸수 있습니다.
 
어떤 명령어는 실행 도중에 변수에도 저장하고 기존의 표준출력과 에러의 출력방향은 모니터를 통해
실시간으로 확인하고 싶을 수도 있습니다.

    #!perl
    my @cmd = qw( find /proc -type f );
    my ($stdout, $stderr, @result) = tee {
        system @cmd;
    };

위의 tee 함수가 그러한 역활을 하고 있습니다. 각각의 출려과 에러를 $stdout, $stderr에 저장하며
 기존의 출력방향으로 그 내용을 출력해 줍니다.
 
위의 언급한 두가자의 특징을 [Capture::Tiny][cpan-capture-tiny]를 통해 좀 더 디테일하게(표준 출력 혹은 에러만 핸들링) 사용 하실수 있습니다.
 

그밖의 주의 사항!
------------------

`보안`
 system 함수에 인자를 전달할때는 위와 같이 배열로 명령어와 각각의 인자를 배열에 담아
실행하는것이 좋습니다.

    #!perl
    #!/usr/bin/env perl

    use strict;
    use warnings;

    my $cmd = 'find / -name' . q{ };
    print "Please input what file do you want to find : ";
    chomp( my $input = <> );

    my $exit_status = system( $cmd . $input );
    
만약 사용자 입력이 `';rm -rf'` 라면

find / -name ;`rm -rf` 가 어떤 상황을 만들어 낼까요?

배열로 argument를 구성하게 되면 각 배열의 요소들을 문자열로 간주하게 되어집니다.

때문에 배열 마지막 요소에 ';rm -rf'가 들어간다면 ';rm -rf' 라는 이름의 파일을 찾으려 합니다.


`Windows 환경에서의 반환값`

리눅스, 유닉스 계열에 익숙한 관리자라면 윈도우에서 외부 명령어를 실행하고 그 반환값을 확인하고 당황 하실 수 도 있습니다.
반환값의 크기가 2Byte이기 때문입니다.(유닉스에서는 1Byte로 제한)

hhhhhhhhllllllll 하위 7비트는 프로그램을 종료한 signal 이 담겨져 있으며, 상위 8비트는 설제 프로그램의 종료 값입니다.

실제 종료 값을 얻기 위해서는 8bit 만큼 우측으로 shift를 하여 그 값을 얻을 수 있습니다.

    #!perl
    my @cmd = 'dir asdf'    # asdf is not existing
    my $ret = system @cmd;  # $ret = 512
    $ret >>= 8;             # $ret = $ret >> 8;
    print "$! : [$ret]";    # No such file or directory : [2]


`SunOS, Solaris, HP-UX 에서의 열려져 있는 파일 핸들과 system()함수`

위에서 언급한바와 같이 위의 외부 명령어를 실행시키기 위해서는

외부 명령어를 위한 자식프로세스를 생성(fork)한다고 했습니다.

fork로 생성된 자식프로세스는 부모의 FD는 물론 아직 소모되지 Output 버퍼도

물려 받게 됩니다.

안전하게 system함수를 사용하기 위해서는 Output 버퍼를 flush 해주고 사용하여야 합니다.

Linux 계열과 Windows 계열에서의 system 함수는 이를 알아서 처리 하므로 고려대상이 아니며

SunOS, Solaris, HP-UX의 O/S 에서는 이를 고려 하여야 합니다.

    #!perl
    local $| = 1;    ## autoflushing
    .
    .
    coding...
    .
    my $ret = system ('command');
    .


위의 방법으로 처리 할수 있습니다.


정리하며
---------

전반적으로 펄을 이용하여 외부 명령어를 실행하는 방법을 알아보았으며,

더불어 Capture::Tiny 모듈을 이용하여 STDOUT과 STDERR를 좀 더 자유롭게 다룰수 있었습니다.

아마 이런 모듈이 없었다면 이런 기능을 직접 구현하기 보다는 STDOUT에서 적절히 타협을 보았을것 같습니다.

다시한번 [CPAN][cpan]이라는 저장소에 놀라며 모듈 개발자에게 감사를 표합니다 :)

_EOT_

[cpan-autodie]:         https://metacpan.org/favorite/autodie
[cpan-capture-tiny]:    https://metacpan.org/pod/Capture::Tiny
[cpan-leaderboard]:     https://metacpan.org/favorite/leaderboard
[cpan]:                 https://metacpan.org
[perldoc-fileno]:       http://perldoc.perl.org/functions/fileno.html
[perldoc-open]:         http://perldoc.perl.org/functions/open.html
[perldoc-system]:       http://perldoc.perl.org/functions/system.html
[perlop-string]:        http://perldoc.perl.org/perlop.html#%60STRING%60

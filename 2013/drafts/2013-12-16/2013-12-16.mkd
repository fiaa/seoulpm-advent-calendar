Title:    Test::Mojo와 함께하는 보다 쉽고 편한 Web Application 테스트
Package:  Seoul.pm
Category: perl
Category: Seoul.pm
Author:   JEEN_LEE


저자
-----

[@JEEN_LEE][twitter-jeen_lee] - 좋은 아빠 워너비, [github:jeen][github-jeen]


## 시작하며

어떻게 하면 테스트 코드를 잘 쓸 수 있을까 하는 고민은 업계에 들어오고, 엉망진창인 테스트코드를 쓰면서도 계속되는 것이었습니다.
그렇다면 "잘 쓴 테스트 코드"는 어떤 것이어야 하는 것일까요?
그걸 알면 제가 이걸 쓰고 있겠습니까?
결론은 좋은 테스트 도구를 만나면 이전과는 다른 "보다 좋은" 테스트를 쓸 수 있지 않을까하고 생각했습니다.
바로 [Test::Mojo](https://metacpan.org/pod/Test::Mojo) 를 사용하면서 말이죠.
그렇기에 이 기사에서 다룰 테스트 어플리케이션은 [Mojolicious](http://mojolicio.us/) 로 만들어 졌다는 것을 전제로 합니다.


## 예전의 테스트코드

그렇다면 "보다 좋게" 쓰기 이전의 테스트코드는 어땠을까요?

#### 컨트롤러/모델 하나하나의 컴파일 테스트

컨트롤러 하나하나 마다 `.t` 파일을 만들어서 정상적으로 컴파일되는 지에 대한 테스트를 확인했었습니다.

``` 
# t/100-controller-user.t
use strict;
use warnings;
use Test::More;

use Catalyst::Test 'MyApp::Web';
use_ok "MyApp::Web::Controller::User";

done_testing();
```

#### 컨트롤러의 기능별 추가

그리고 각 컨트롤러의 기능(API Endpoint) 별로 리퀘스트를 날리고,
그에 따른 결과를 파싱해서 이런 값이 있어야 되겠지 하면서 한줄한줄 적어갔었습니다.

```
# t/101-controller-user-get.t
use strict;
use warnings;
use Test::More;
use HTTP::Request::Common;

use Catalyst::Test 'MyApp::Web';
use JSON::XS;

my $res = request(
  GET "/user/1",
    "X-MyApp-Token" => "f9a077fae03cf63bc4b351344531bde91f0f26c9",
);

my $data = JSON::XS::decode_json($res->content);
ok($data->{user}, "Got User Data");
ok(defined $data->{user}->{rate}, "Got User-Rate");
ok(defined $data->{user}->{photo}, "Got-User-Photo");
ok(defined $data->{user}->{count}, "Got-User-Counts");
ok(defined $data->{isFriend}, "ok");
ok(defined $data->{user}->{count}, "Ok");
ok(defined $data->{me}, "OK");
done_testing();
```

#### 모듈/어플리케이션의 의존성관리

가끔 테스트를 돌리려면 `Can't locate XXX/XXX.pm ....` 이라는 아주 친숙한 에러가 반길때가 있습니다.
그렇습니다. 바로 의존성관리를 제대로 하지 못해서 발생하게 되는 것이었습니다.
어플리케이션의 배포를 위해서 `Makefile.PL` 에 일일이 의존모듈을 추가해주고
`cpanm --installdeps .` 를 통해서 의존이 걸린 모듈들을 매번 설치해줘야 할 필요가 있었습니다.


## 그렇다면 어떻게 바뀌었나?

#### `lib` 디렉토리 아래의 모듈파일의 전체 컴파일 테스트

프로젝트를 구성하는 모든 네임스페이스의 모듈을 한번에 테스트하도록 합니다.
이를 통해서 컨트롤러 하나하나, 모델 하나하나에 들였던 불필요한 시간은 날아가버립니다.
 
동시에 프로젝트에서 주로 사용하던 동적 클래스 로딩으로 호출되던 많은 모듈들도 한번에 처리할 수 있습니다.


```
# t/000-compile.t
use Test::Ika;
use Test::More;
use Path::Class::Rule;
use utf8;

BEGIN { binmode STDOUT, ":utf8" };

describe "Compile" => sub {
    it "모든 패키지는 정상적으로 로딩되어야 한다" => sub {
        my $rule = Path::Class::Rule->new;
        $rule->file->name(qr/\.pm$/);  # .pm 파일들 만을 뽑아냄
        $rule->file->size('>10');  # 네임스페이스 선정을 위해서 가끔 개발도중에 0byte 모듈 파일을 형식상으로 만들어두던 습관때문에...
        my $iter = $rule->iter('lib');  # lib 디렉토리 하위의 모든 파일들에 대해
        while(my $file = $iter->()) {
            my $pkg = $file;
            $pkg =~ s!^lib/!!;
            $pkg =~ s!\.pm$!!;
            $pkg =~ s!/!::!g;
            use_ok $pkg;
        }
    };
};
```

#### 각 테스트 단위의 서술

Ruby 의 RSpec 의 표현식을 빌려서 사용할 수 있는 [Test::Ika](https://metacpan.org/pod/Test::Ika) 모듈을
통해서 위처럼 테스트를 정의할 수 있습니다. 

이를 사용해서 기존 단순명료했던 `TAP` 의 출력결과와는 달리 각 테스트코드들에서 서술된 표현들을 깔끔하게 표시해줍니다.

![](https://dl.dropboxusercontent.com/u/262117/adv-pic-003.png)

이전의 테스트코드에서는 [Test::More#subtest](https://metacpan.org/pod/Test::More) 를 사용해서 이런 식의 서술을 했었지요.

이처럼 테스트 단위의 서술을 기재함으로 얻는 이점이란, 테스트코드를 통해서 문서화를 병용할 수 있다는 점이라고...
테스트 코드에서 얻을 수 있는 그런 부분과는 다른 문서를 별도로 쓰고 있지만...
나름 잘 구분해서 사용하면 효과적이지 않을까 하고 생각합니다.

#### `Test::Mojo`

HTTP Client 중에 정말 간결하게 사용할 수 있는 것이 [Mojo::UserAgent](https://metacpan.org/pod/Mojo::UserAgent) 인데,
이 타이틀에서 주로 다루는 Web API Server 에서 주로 다루게 되는 응답결과인
JSON의 각 항목들을 테스트하기 위해서는 정말 이만한 게 없었습니다.
물론 여기에서 사용되는 `Test::Mojo` 자체가 `Mojo::UserAgent` 를 래핑하는 형식을 취하고 있습니다만.

```
use Mojo::Base -strict;
use Test::Ika;
use Test::Mojo;

BEGIN { binmode STDOUT, ":utf8" };

my $t = Test::Mojo->new('MyApp::Web');

describe "Noop" => sub {

    it "서버간의 연결확인 등의 목적으로 하는 무작업 응답이 필요함" => sub {
        $t->get_ok('/noop')
           ->status_is(200)
           ->json_has('/noop');
    };

    it "인증토큰을 가지지 않은 채로 무작업 응답 요청시에 400을 표시해야 함" => sub {
        $t->get_ok('/noop/auth')
	       ->status_is(400)
	       ->json_has('/message');
    };

    it "인증토큰을 가지고 있을 때는 무작업 응답 요청에 답해야 함" => sub {
        $t->ua->on( start => sub {
            my ($ua, $tx) = @_;
            $tx->req->headers->header('X-MyApp-Token', 'xxxxxxxxxxxx');
        });

        $t->get_ok('/noop/auth')
	       ->status_is(200)
	       ->json_has('/noop')
	       ->json_has('/result/ok')
	       ->json_has('/devices/0/id')
    };
};
```

위의 테스트코드처럼 `->json_has` 를 통해서 HTTP Response 가 JSON 이었을 시에,
반환되는 JSON 데이터를 Perl 데이터구조로 받아들여서,
`/devices/0/id` (`devices` 배열 항목의 첫번째 요소의 `id` 키값) 이 있는 지 여부 등을 확인할 수 있는 것입니다.
이런 데이터접근방식을 `JSON Pointer` 라고 부릅니다 

- [RFC 9601  JavaScript Object Notation (JSON) Pointer](http://tools.ietf.org/html/rfc6901)

위에서 볼 수 있듯이 `Test::Mojo` 자체는 메소드 체이닝으로 동작하기에
보기에는 나름 깔끔하게(또는 여느 때처럼 보는 펄 같지 않는 것처럼) 느껴지기도 합니다.
 

#### 프로젝트/모듈의 의존성 관리

`Carton` 과 `cpanfile` 을 사용합니다.
기본적으로 위의 `t/000-compile.t` 에서 모든 모듈들의 컴파일 테스트시에
반드시 의존모듈의 누락여부를 확인할 수 있고,
그때그때 큰 죄의식없이 `cpanfile` 에 필요한 의존모듈을 추가하면 됩니다.

매회의 테스트는 아래의 커맨드로 실행됩니다.

```
$ carton install
$ carton exec prove t
```

`Carton` 및 `cpanfile` 는 여기에서 다루지 않는 것으로 합니다.

#### 테스트 자동화

배포되는 모듈/어플리케이션의 모든 테스트는 Jenkins 상에서 커밋단위 && 일단위로 이뤄집니다.
이에 대한 이야기는 KPW2012 의 발표에서 다룬 적이 있으므로 추가로 언급하지 않습니다.

- [Perl Web App 테스트 전략 : Slideshare ](http://www.slideshare.net/JEEN/perl-web-app)

## 정리하며

`A 를 고쳤는데 B 가 안된다` 라는 식은땀나는 상황은 언제 어디서고 일어나기 마련입니다.
물론 이런저런 테스트 코드를 쓰는 기법과 좋은 방법론들이 세상에는 많지만,
저처럼 배움이 느린 사람에게 있어서는 어려운 이야기인지라...
좀 더 좋은 방법에 대해서 갈망하는 자세를 잊어서는 안되리라 생각합니다.

> Machine should work, People should think

어디에선가 주워들은 글귀입니다만,

누가(기계가), 언제(커밋/특정시간), 어디서(개발서버), 무엇을(이런 저런 항목들을), 어떻게(요래조래), 왜(마음의 평화를 위해)...
두번 이상 반복될 것들은 기계에서 맡기며 다른 일들에 눈을 돌리는 조바심내는 개발자가 되기를 바랍니다(제가).


[github-jeen]:                    https://github.com/jeen
[twitter-jeen_lee]:               http://twitter.com/#!/JEEN_LEE
